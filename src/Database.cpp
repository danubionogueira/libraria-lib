#include "Database.hpp"
#include <string>
#include "Utils.hpp"
#include <exception>

using std::exception;

using std::string;
using std::to_string;

int SQLException::getCode(){
	return code;
}

const char* SQLException::what(){
	return message.c_str();
}

SQLException::SQLException(int code, const char* what){
	this->code = code;
	this->message = string(what);
}

string User::getName(){
	return name;
}

string User::getPassword(){
	return password;
}

User::User(const string name, const string password){
	this->name = name;
	this->password = password;
}

string Server::getName(){
	return name;
}

unsigned int Server::getPort(){
	return port;
}

Server::Server(const string name, const unsigned int port){
	this->name = name;
	this->port = port;
}

Server* Database::getServer(){
	return server;
}

string Database::getPath(){
	return path;
}

User* Database::getUser(){
	return user;
}

void Database::create(){
	ibdb->Create(3);
	connect();
}

void Database::drop(){
	connect();
	ibdb->Drop();
}

void Database::recreate(){
	try{
		drop();
	}
	catch (IBPP::SQLException& e){
		SQLException* ex = new SQLException(e.EngineCode(), e.what());

		if (ex->getCode() != 335544344)
			throw ex;
	}

	create();
}

void Database::connect(){
	if (!connected())
		ibdb->Connect();
}

void Database::disconnect(){
	if (connected())
		ibdb->Disconnect();
}

bool Database::connected(){
	return ibdb->Connected();
}

Database::Database(Server* server, const string path, User* user){
	this->server = server;
	this->path = path;
	this->user = user;

	string sname = server->getName();
	string dname = path;
	string uname = user->getName();
	string pass = user->getPassword();
	unsigned int port = server->getPort();

	if (port > 0)
		sname = sname + "/" + to_string(port);

	ibdb = IBPP::DatabaseFactory(
		sname, 
		dname, 
		uname, 
		pass,
		"",
		"",
		"PAGE_SIZE = 4096"
	);
}

Database::~Database(){
	disconnect();
}

Database* Transaction::getDatabase(){
	return database;
}

void Transaction::start(){
	if (ibtr == NULL)
		ibtr = IBPP::TransactionFactory(
			database->ibdb,
			IBPP::amWrite,
			IBPP::ilReadCommitted,
			IBPP::lrNoWait,
			IBPP::TFF(0)
		);

	if (!started())
		ibtr->Start();
}

void Transaction::commit(){
	ibtr->CommitRetain();
}

void Transaction::rollback(){
	ibtr->Rollback();
	start();
}

bool Transaction::started(){
	return (
		(ibtr == NULL) ||
		(ibtr->Started())
	);
}

Transaction::Transaction(Database* database){
	this->database = database;
	ibtr = NULL;
}

Transaction* Statement::getTransaction(){
	return transaction;
}

void Statement::executeSQL(const string sql){
	transaction->start();

	ibst = IBPP::StatementFactory(
		transaction->database->ibdb,
		transaction->ibtr
	);

	ibst->ExecuteImmediate(sql);
}

int Statement::getColumnAsInt(const string name){
	int result;
	ibst->Get(name, result);
	return result;
}

string Statement::getColumnAsString(const string name){
	string result;
	ibst->Get(name, result);
	return result;
}

Statement::Statement(Transaction* transaction){
	this->transaction = transaction;
	ibst = NULL;
}

string ColumnMetaData::getType(){
	return type;
}

string ColumnMetaData::getName(){
	return name;
}

unsigned int ColumnMetaData::getLength(){
	return length;
}

ColumnMetaData::ColumnMetaData(const string type, const string name, unsigned int length){
	this->type = type;
	this->name = name;
	this->length = length;
}

string TableMetadata::getName(){
	return name;
}

TableMetadata::TableMetadata(string name){
	this->name = name;
}

TableMetadata::~TableMetadata(){
}

TableMetadata* Column::getTable(){
	return table;
}

int Column::getAsInteger(){
	return statement->getColumnAsInt(getName());
}

string Column::getAsString(){
	return statement->getColumnAsString(getName());
}

Column::Column(
	TableMetadata* table,
	const string type,
	const string name,
	const unsigned int length
): ColumnMetaData(type, name, length){
	this->table = table;

	Table* tb = dynamic_cast<Table*>(table);

	if (tb != nullptr)
		tb->addColumn(this);
}

VarcharColumn::VarcharColumn(
	TableMetadata* table,
	const string name,
	unsigned int length
): Column(table, "VARCHAR", name, length){
}

IntegerColumn::IntegerColumn(TableMetadata* table, const string name):
	Column(table, "INTEGER", name, 0){
}

IdentifierColumn::IdentifierColumn(
	TableMetadata* table,
	const string name
): Column(table, "INTEGER GENERATED BY DEFAULT AS IDENTITY", name, 0){
}

const char* InvalidTableException::what(){
	return "Table is invalid";
}

TableMetadata* PrimaryKey::getTable(){
	return table;
}

string PrimaryKey::getName(){
	return name;
}

void PrimaryKey::add(Column* column){
	if (table == NULL)
		table = column->getTable();
	else if (table != column->getTable())
		throw InvalidTableException();

	columns.push_back(column);
}

Column* PrimaryKey::at(const size_t idx){
	return columns.at(idx);
}

const size_t PrimaryKey::size(){
	return columns.size();
}

void PrimaryKey::create(Transaction* transaction){
	Statement* stmt = new Statement(transaction);
	size_t size = columns.size();
	string sql = "ALTER TABLE " + table->getName() + " ADD CONSTRAINT ";

	if (name == "")
		name = table->getName() + "_pk";

	sql = sql + name + " PRIMARY KEY(\n";

	for (size_t i=0; i<size; i++){
		Column* column = columns.at(i);
		sql = sql + "\t" + column->getName();

		if (i<size-1)
			sql = sql + ",";

		sql = sql + "\n";
	}

	sql = sql + ");\n";
	stmt->executeSQL(sql);
}

void PrimaryKey::drop(Transaction* transaction){
	Statement* stmt = new Statement(transaction);
	string sql = "ALTER TABLE " + table->getName() + " DROP CONSTRAINT " + name + ";\n";
	stmt->executeSQL(sql);
}

PrimaryKey::PrimaryKey(TableMetadata* table, const string name){
	this->name = name;
	this->table = table;

	Table* tb = dynamic_cast<Table*>(table);

	if (tb != nullptr)
		tb->setPrimaryKey(this);
}

Column* ForeignKeyReference::getColumn(){
	return column;
}

Column* ForeignKeyReference::getReference(){
	return reference;
}

ForeignKeyReference::ForeignKeyReference(Column* column, Column* reference){
	this->column = column;
	this->reference = reference;
}

TableMetadata* ForeignKey::getTable(){
	return table;
}

string ForeignKey::getName(){
	return name;
}

void ForeignKey::add(ForeignKeyReference* reference){
	if (table != reference->getColumn()->getTable())
		throw InvalidTableException();
	else if (this->reference != reference->getReference()->getTable())
		throw InvalidTableException();

	references.push_back(reference);
}

void ForeignKey::add(Column* column, Column* reference){
	add(new ForeignKeyReference(column, reference));
}

ForeignKeyReference* ForeignKey::at(const size_t idx){
	return references.at(idx);
}

const size_t ForeignKey::size(){
	return references.size();
}

void ForeignKey::create(Transaction* transaction){
	Statement* stmt = new Statement(transaction);
	size_t size = references.size();
	string sql = "ALTER TABLE " + getTable()->getName() + " ADD CONSTRAINT " + name + " FOREIGN KEY(\n";
	string reftable;

	for (size_t i=0; i<size; i++){
		ForeignKeyReference* reference = references.at(i);
		sql = sql + "\t" + reference->getColumn()->getName();
	}

	sql = sql + "\n) REFERENCES " + reference->getName() + "(\n";

	for (size_t i=0; i<size; i++){
		ForeignKeyReference* reference = references.at(i);
		sql = sql + "\t" + reference->getReference()->getName();
	}

	sql = sql + "\n);";
	stmt->executeSQL(sql);
}

void ForeignKey::drop(Transaction* transaction){
	Statement* stmt = new Statement(transaction);
	string sql = "ALTER TABLE " + getTable()->getName() + " DROP CONSTRAINT " + name + ";";
	stmt->executeSQL(sql);
}

ForeignKey::ForeignKey(TableMetadata* table, TableMetadata* reference, const string name){
	this->name = name;
	this->table = table;
	this->reference = reference;

	Table* tb = dynamic_cast<Table*>(table);

	if (tb != nullptr)
		tb->addForeignKey(this);
}

void Table::addColumn(Column* column){
	if (column->getTable() != this)
		throw InvalidTableException();

	columns.push_back(column);
}

void Table::setPrimaryKey(PrimaryKey* primaryKey){
	if (primaryKey->getTable() != this)
		throw InvalidTableException();

	this->primaryKey = primaryKey;
}

void Table::addForeignKey(ForeignKey* foreignKey){
	if (foreignKey->getTable() != this)
		throw InvalidTableException();

	foreignKeys.push_back(foreignKey);
}

Column* Table::columnAt(const size_t idx){
	return columns.at(idx);
}

const size_t Table::columnsSize(){
	return columns.size();
}

PrimaryKey* Table::getPrimaryKey(){
	return primaryKey;
}

ForeignKey* Table::foreignKeyAt(const size_t idx){
	return foreignKeys.at(idx);
}

const size_t Table::foreignKeysSize(){
	return foreignKeys.size();
}

void Table::create(Transaction* transaction){
	Statement* stmt = new Statement(transaction);
	const size_t size = columns.size();
	string sql = "CREATE TABLE " + getName() + "(\n";;

	for (size_t i=0; i<size; i++){
		Column* column = columns.at(i);
		unsigned int length = column->getLength();

		sql = sql + "\t" + column->getName() + " " + column->getType();

		if (length > 0)
			sql = sql + "(" + Utils::toString(length) + ")";

		if (i < size-1)
			sql = sql + ",";

		sql = sql + "\n";
	}

	sql = sql + ");\n";
	stmt->executeSQL(sql);

	if (primaryKey != NULL)
		primaryKey->create(transaction);

	for (size_t i=0; i<foreignKeys.size(); i++){
		ForeignKey* foreignKey = foreignKeys.at(i);
		foreignKey->create(transaction);
	}
}

void Table::drop(Transaction* transaction){
	string sql = "DROP TABLE " + getName() + ";\n";
	Statement* stmt = new Statement(transaction);
	stmt->executeSQL(sql);
}

Table::Table(const string name): TableMetadata(name){
	primaryKey = NULL;
}
